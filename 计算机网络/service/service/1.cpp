/* * @Description: * @version: 1.0.0 * @Author: yrp * @Date: 2023-09-26 19:15:35 * @LastEditTime: 2023-09-26 19:25:10 */#pragma once#define _WINSOCK_DEPRECATED_NO_WARNINGS#include "winsock2.h"#include "Config.h"#include <stdio.h>#include <iostream>#include <string>#pragma comment(lib, "ws2_32.lib")using namespace std;void main(){	// 依据配置文件配置初始信息	if (Config::setConfig())	{		cout << "init failed!" << endl;		return;	}	WSADATA wsaData;	fd_set wfds;				//Long类型的数组，每一个数组元素可与一打开的文件句柄建立联系	fd_set rfds;				//用于检查socket是否有数据到来的的文件描述符，用于socket非阻塞模式下等待网络事件通知（有数据到来）	bool first_connetion = true;	int nRc = WSAStartup(0x0202, &wsaData);	if (nRc) {		printf("Winsock  startup failed with error!\n");	}	if (wsaData.wVersion != 0x0202) {		printf("Winsock version is not correct!\n");		WSACleanup();		return;	}	printf("Winsock  startup Ok!\n");	SOCKET srvSocket;	sockaddr_in addr, clientAddr;	SOCKET sessionSocket;	string clientAddress;	int addrLen;	//create socket	srvSocket = socket(AF_INET, SOCK_STREAM, 0);//创建套接字	if (srvSocket != INVALID_SOCKET)		printf("Socket create Ok!\n");	//set port and ip	addr.sin_family = AF_INET;	addr.sin_port = htons(Config::PORT);//端口号为5050	//addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);	addr.sin_addr.S_un.S_addr = inet_addr(Config::SERVICE_ADDRESS.c_str());//配置ip	//binding	int rtn = bind(srvSocket, (LPSOCKADDR)&addr, sizeof(addr));	if (rtn != SOCKET_ERROR)		printf("Socket bind Ok!\n");	else {		cout << "Socket bind Error!" << WSAGetLastError() << endl;		closesocket(srvSocket);		WSACleanup();	}//listen	rtn = listen(srvSocket, 5);//创建一个套接口并监听申请的连接.	if (rtn != SOCKET_ERROR)		printf("Socket listen Ok!\n");	else cout << "Socket listen Ok!" << WSAGetLastError() << endl;	addrLen = sizeof(clientAddr);	u_long blockMode = 1;//将srvSock设为非阻塞模式以监听客户连接请求	if ((rtn = ioctlsocket(srvSocket, FIONBIO, &blockMode) == SOCKET_ERROR)) { //FIONBIO：允许或禁止套接口s的非阻塞模式。		cout << "ioctlsocket() failed with error!\n";		return;	}	cout << "ioctlsocket() for server socket ok!	Waiting for client connection and data\n";	char* recvBuf = new char[Config::BUFFER_LENGTH]();	memset(recvBuf, '\0', Config::BUFFER_LENGTH);	while (true) {		//清空read,write描述符		FD_ZERO(&rfds);		FD_ZERO(&wfds);		//设置等待客户连接请求		FD_SET(srvSocket, &rfds);		if (!first_connetion) {			//设置等待会话SOKCET可接受数据或可发送数据			FD_SET(sessionSocket, &rfds);			FD_SET(sessionSocket, &wfds);		}		//开始等待		int nTotal = select(0, &rfds, &wfds, NULL, NULL);		//如果srvSock收到连接请求，接受客户连接请求		if (FD_ISSET(srvSocket, &rfds)) {//测试srvSocket是否可读，即是否网络上有数据			nTotal--;			//产生会话SOCKET			sessionSocket = accept(srvSocket, (LPSOCKADDR)&clientAddr, &addrLen);			if (sessionSocket != INVALID_SOCKET)				printf("Socket listen one client request!\n");			//把会话SOCKET设为非阻塞模式			if ((rtn = ioctlsocket(sessionSocket, FIONBIO, &blockMode) == SOCKET_ERROR)) { //FIONBIO：允许或禁止套接口s的非阻塞模式。				cout << "ioctlsocket() failed with error!\n";				return;			}			cout << "ioctlsocket() for session socket ok!	Waiting for client connection and data\n";			//设置等待会话SOKCET可接受数据或可发送数据			FD_SET(sessionSocket, &rfds);			FD_SET(sessionSocket, &wfds);			first_connetion = false;		}		//检查会话SOCKET是否有数据到来		if (nTotal > 0)		{		}	}}