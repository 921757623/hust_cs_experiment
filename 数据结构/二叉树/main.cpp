#include "def.h"
#include "f.h"

int main() {
    TElemType definition[100] , data;
    BiTree T = NULL, t = NULL;
    LISTS Lists;
    Lists.length = 0;
    Lists.listsize = LIST_INIT_SIZE;
    char file_name[40],list_name[20];
    int op = 1;
    int value, num, i, record = 0;  //保存函数返回值 
    while(op) {
        system("cls");	printf("\n\n");
        printf("      Menu for Linear Table On Sequence Structure \n"    );
        printf("-------------------------------------------------\n"     );
        printf("    	  1. CreatrBiTree      2. ClearBiTree\n"         );
        printf("          3. BiTreeDepth       4. LocateNode\n"          );
        printf("          5. Assign            6. GetSibling\n"          );
        printf("          7. InsertNode        8. DeleteNode\n"          );
        printf("          9. PreOrderTraverse  10.InOrderTraverse\n"     );
        printf("          11.PostOrderTraverse 12.LevelOrderTraverse\n"  );
        printf("          13.SaveBiTree        14.LoadBiTree\n"          );
        printf("          15.MaxPathSum        16.LowestCommonAncestor\n");
        printf("          17.InvertTree        18.AddList\n"             );
        printf("          19.TreeChange        20.BiTreeEmpty\n"         );
        printf("           0.exit\n"                                     );
        printf("-------------------------------------------------\n"     );
        printf("    请选择你的操作[0~20]: "				  );

        scanf("%d",&op);
        switch(op) {
                case 1: if(T != NULL) printf("已经创建该结点!\n");
                        else {
                        printf("请输入结点数据:\n");
                        i = 0;
                        do {
                                scanf("%d%s",&definition[i].key,definition[i].others);
                        } while (definition[i++].key!=-1);
                        value = CreateBiTree(T,definition);
                        Lists.elem[record].T = T;
                        if(value == OK) printf("创建成功!\n");
                        else printf("创建失败,出现相同关键字!\n");
                        }
                        getchar(); getchar();
                        break;
                case 2: value = ClearBiTree(T);
                        if(value == OK) printf("二叉树清空完毕!\n");
                        getchar(); getchar();
                        break;
                case 3: value = BiTreeDepth(T);
                        if(value >= 0) printf("二叉树的深度为: %d",value);
                        else printf("出错啦!\n");
                        getchar(); getchar();
                        break;
                case 4: printf("请输入查找结点的关键字: ");
                        scanf("%d",&i);
                        t = NULL;
                        t = LocateNode(T,i);
                        if(t != NULL) printf("已查找到该结点: %d %s\n",t->data.key,t->data.others);
                        else printf("没有查找到该结点!\n");
                        getchar(); getchar();
                        break;
                case 5: printf("请输入要赋值的结点的关键字: ");
                        scanf("%d", &i);
                        printf("请输入赋值的内容: ");
                        scanf("%d%s\n",&data.key,data.others);
                        value = Assign(T,i,data);
                        if(value == OK) printf("结点已赋值完毕!\n");
                        else printf("没有查找到该结点!\n");
                        getchar(); getchar();
                        break;
                case 6: printf("请输入要查询的结点的关键字: ");
                        scanf("%d",&i);
                        t = NULL;
                        t = GetSibling(T,i);
                        if(t != NULL) printf("已查找到该结点的兄弟结点: %d %s\n",t->data.key,t->data.others);
                        else printf("没有查找到该结点或者该结点无兄弟结点!\n");
                        getchar(); getchar();
                        break;
                case 7: printf("请输入插入结点的关键字: ");
                        scanf("%d",&i);
                        printf("请输入插入的位置,0为左子树,1为右子树,-1为根结点插入\n");
                        scanf("%d",&num);
                        printf("请输入插入结点的数据: ");
                        scanf("%d%s",&data.key,data.others);
                        value = InsertNode(T,i,num,data);
                        if(value == OK) printf("插入成功!\n");
                        else printf("插入失败!\n");
                        getchar(); getchar();
                        break;
                case 8: printf("请输入要删除结点的关键字: ");
                        scanf("%d",&i);
                        value = DeleteNode(T,i);
                        if(value == OK) printf("删除成功!\n");
                        else printf("删除失败!\n");
                        getchar(); getchar();
                        break;
                case 9: value = PreOrderTraverse(T,visit);
                        if(value == ERROR) printf("二叉树为空!\n");
                        getchar(); getchar();
                        break;
                case 10:value = InOrderTraverse(T,visit);
                        if(value == ERROR) printf("二叉树为空!\n");
                        getchar(); getchar();
                        break;
                case 11:value = PostOrderTraverse(T,visit);
                        if(value == ERROR) printf("二叉树为空!\n");
                        getchar(); getchar();
                        break;
                case 12:value = LevelOrderTraverse(T,visit);
                        if(value == ERROR) printf("二叉树为空!\n");
                        getchar(); getchar();
                        break;
                case 13:printf("请输入要储存的位置:\n");
                        scanf("%s",file_name);
                        value = SaveBiTree(T,file_name);
                        if(value == OK) printf("储存成功!\n");
                        else printf("存储失败!\n");
                        getchar(); getchar();
                        break;
                case 14:printf("请输入要读取的位置:\n");
                        scanf("%s",file_name);
                        value = LoadBiTree(T,file_name);
                        if(value == OK) printf("读取成功!\n");
                        else printf("读取失败!\n");
                        getchar(); getchar();
                        break;
                case 15:value = MaxPathSum(T);
                        printf("最大路径和为: %d\n",value);
                        getchar(); getchar();
                        break;
                case 16:printf("请输入两个结点的关键字: ");
                        scanf("%d%d",&i,&num);
                        t = NULL;
                        t = LowestCommonAncestor(T,i,num);
                        if(t != NULL) printf("找到公共祖先: %d %s\n",t->data.key,t->data.others);
                        else printf("没有找到该公共祖先!\n");
                        getchar(); getchar();
                        break;
                case 17:value = InvertTree(T);
                        if(value == OK) printf("翻转完成!\n");
                        else printf("翻转失败!\n");
                        getchar(); getchar();
                        break;
                case 18:printf("请输入新建树的名字: ");
                        scanf("%s",list_name);
                        value = AddList(Lists,list_name);
                        if(value == OK) printf("新建成功!\n");
                        else if(value == ERROR) printf("命名重复!\n");
                        else printf("超出最大容量!\n");
                        getchar(); getchar();
                        break;
                case 19:printf("请更换新建树的名字: ");
                        scanf("%s",list_name);
                        T = TreeChange(Lists,list_name,record);
                        printf("更换完毕!\n");
                        getchar(); getchar();
                        break;
                case 20:value = BiTreeEmpty(T);
                        if(value == TRUE) printf("二叉树为空!");
                        else printf("二叉树不为空!");
                        getchar(); getchar();
                        break;
                }
        }
	printf("欢迎下次再使用本系统！\n");
        return 0;
}